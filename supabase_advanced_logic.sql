
-- 1. Profiles Table Extension (for Points & Orders Count)
ALTER TABLE public.profiles 
ADD COLUMN IF NOT EXISTS points int DEFAULT 0,
ADD COLUMN IF NOT EXISTS total_orders int DEFAULT 0,
ADD COLUMN IF NOT EXISTS tier text DEFAULT 'MEMBER'; -- MEMBER, GOLD, VIP

-- 2. Lotto Pool Table (à¹€à¸à¹‡à¸šà¹€à¸¥à¸‚à¸«à¸§à¸¢)
CREATE TABLE IF NOT EXISTS public.lotto_pool (
    id bigint generated by default as identity primary key,
    order_id bigint references public.orders(id),
    user_id uuid references auth.users, -- à¸­à¸²à¸ˆà¹€à¸›à¹‡à¸™ null à¹„à¸”à¹‰à¸–à¹‰à¸²à¹€à¸›à¹‡à¸™ guest (à¹à¸•à¹ˆà¹ƒà¸™ processOrder à¹€à¸£à¸² insert guest à¹„à¸¡à¹ˆà¹„à¸”à¹‰à¹ƒà¸™ orders table à¹à¸šà¸šà¸™à¸µà¹‰à¸–à¹‰à¸² guest à¸ªà¸±à¹ˆà¸‡ à¸ˆà¸°à¹„à¸¡à¹ˆà¸¡à¸µ user_id)
    -- à¹à¸à¹‰à¹„à¸‚: user_id à¸„à¸§à¸£ allow null à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ? à¹ƒà¸™ supabase schema à¹€à¸”à¸´à¸¡ orders.user_id references auth.users 
    -- à¸–à¹‰à¸² guest à¸ªà¸±à¹ˆà¸‡à¹à¸šà¸š Anonymous Auth à¸ˆà¸°à¸¡à¸µ user_id à¹à¸šà¸š anon
    number text not null, -- à¹€à¸¥à¸‚à¸—à¹‰à¸²à¸¢ 2 à¸•à¸±à¸§
    draw_date date not null, -- à¸‡à¸§à¸”à¸§à¸±à¸™à¸—à¸µà¹ˆ
    created_at timestamp with time zone default timezone('utc'::text, now())
);

-- RLS for Lotto Pool
ALTER TABLE public.lotto_pool enable row level security;
CREATE POLICY "Users can view their own lotto numbers" on public.lotto_pool for select using (auth.uid() = user_id);
-- Admin can view all (need service role policy if using client admin, but usually admin uses dashboard)

-- 3. Point Logs Table (à¸›à¸£à¸°à¸§à¸±à¸•à¸´à¹à¸•à¹‰à¸¡)
CREATE TABLE IF NOT EXISTS public.point_logs (
    id bigint generated by default as identity primary key,
    user_id uuid references auth.users not null,
    action text not null, -- EARN, REDEEM
    amount int not null,
    order_id bigint, -- Optional reference
    note text,
    balance_after int,
    created_at timestamp with time zone default timezone('utc'::text, now())
);

-- RLS for Point Logs
ALTER TABLE public.point_logs enable row level security;
CREATE POLICY "Users can view their own point logs" on public.point_logs for select using (auth.uid() = user_id);

-- 4. Lotto Results Table (à¸œà¸¥à¸«à¸§à¸¢)
CREATE TABLE IF NOT EXISTS public.lotto_results (
    draw_date date primary key,
    last2 text not null,
    first3 text,
    created_at timestamp with time zone default timezone('utc'::text, now())
);

-- RLS for Lotto Results (Public Read)
ALTER TABLE public.lotto_results enable row level security;
CREATE POLICY "Anyone can view lotto results" on public.lotto_results for select using (true);


-- ==========================================
-- ðŸ§  DATABASE FUNCTIONS (SERVER-SIDE LOGIC)
-- ==========================================

-- Function: Process Order (Triggered AFTER INSERT on orders where status='PLACED')
-- NOTE: In client app, we first INSERT status='cart'. When checking out, we UPDATE status='placed'.
-- So we need a TRIGGER on UPDATE.

CREATE OR REPLACE FUNCTION public.handle_order_placed()
RETURNS TRIGGER AS $$
DECLARE
    earned_points int := 0;
    customer_tier text;
    lotto_num text;
    next_draw date;
BEGIN
    -- Only run when status changes to 'placed' (or 'cooking' etc but 'placed' is reliable start)
    IF NEW.status = 'placed' AND (OLD.status = 'cart' OR OLD.status IS NULL) THEN
        
        -- 1. Calculate Points (Rule: 10 Baht = 1 Point, for example. Adjust logic as needed.)
        -- From GAS: pEarned is passed from client. Here is safer to calculate.
        -- Let's assume logic: Floor(Total / 10). Or use what's in JSON if we trust client? 
        -- Safer: Calculate here.
        earned_points := FLOOR(NEW.total_price / 10);
        
        -- 2. Update Wallet (Profiles)
        UPDATE public.profiles 
        SET points = points + earned_points,
            total_orders = total_orders + 1,
            updated_at = now()
        WHERE id = NEW.user_id
        RETURNING tier INTO customer_tier;
        
        -- 3. Log Points Transaction
        IF earned_points > 0 THEN
            INSERT INTO public.point_logs (user_id, action, amount, order_id, note, balance_after)
            VALUES (NEW.user_id, 'EARN', earned_points, NEW.id, 'Order: ' || NEW.id, (SELECT points FROM public.profiles WHERE id = NEW.user_id));
        END IF;

        -- 4. Generate Lotto Ticket
        -- Logic: Take last 2 digits of Order ID. Since Order ID is BigInt, convert to text.
        -- But wait, your GAS used "KP-XXXXXX". Supabase ID is BigInt (1, 2, 3...).
        -- Let's pad it strictly? Or use the ID directly.
        -- Logic: Right(ID::text, 2).
        lotto_num := RIGHT(NEW.id::text, 2);
        IF LENGTH(lotto_num) < 2 THEN
            lotto_num := LPAD(lotto_num, 2, '0');
        END IF;
        
        -- Calculate Draw Date (1st or 16th)
        -- Logic from GAS:
        -- if day > 1 and day < 16 -> 16th current month
        -- if day >= 16 -> 1st next month
        -- else (day 1) -> 1st current month (handled by day>1 check? No. Day 1 is Day 1.)
        -- PostgreSQL logic:
        IF EXTRACT(DAY FROM now()) > 1 AND EXTRACT(DAY FROM now()) < 16 THEN
             next_draw := make_date(EXTRACT(YEAR FROM now())::int, EXTRACT(MONTH FROM now())::int, 16);
        ELSIF EXTRACT(DAY FROM now()) >= 16 THEN
             next_draw := (date_trunc('month', now()) + interval '1 month')::date; -- 1st of next month
        ELSE
             next_draw := make_date(EXTRACT(YEAR FROM now())::int, EXTRACT(MONTH FROM now())::int, 1);
        END IF;

        INSERT INTO public.lotto_pool (order_id, user_id, number, draw_date)
        VALUES (NEW.id, NEW.user_id, lotto_num, next_draw);

    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger Definition
DROP TRIGGER IF EXISTS on_order_placed ON public.orders;
CREATE TRIGGER on_order_placed
AFTER UPDATE ON public.orders -- Monitor Update from 'cart' to 'placed'
FOR EACH ROW
EXECUTE FUNCTION public.handle_order_placed();

-- Also trigger on Insert if status is already placed (rare but possible)
DROP TRIGGER IF EXISTS on_order_insert_placed ON public.orders;
CREATE TRIGGER on_order_insert_placed
AFTER INSERT ON public.orders
FOR EACH ROW
EXECUTE FUNCTION public.handle_order_placed();
